//
// Created by paren on 22/05/2025.
//

#pragma once

#include <atomic>
#include <memory>
#include <shared_mutex>
#include <string>
#include <unordered_map>
#include <vector>

#include "Instruction.h"
#include "PagingAllocator.h"

enum ProcessStatus { READY, RUNNING, WAITING, DONE };
enum MemorySegment { TEXT, DATA, HEAP };

struct PageEntry {
    int frameNumber = -1;
    bool isValid = false;
    bool inBackingStore = false;
    bool isDirty = false;
};

using PageData = std::vector<std::optional<StoredData>>;

/**
 * @class Process
 * @brief Represents a simulated process with logging and line-tracking
 * features.
 */
class Process {
public:
    /**
     * @brief Constructs a Process object.
     * @param id The unique identifier for the process.
     * @param name The name of the process.
     */
    Process(int id, const std::string& name);
    Process(int id, const std::string& name, uint64_t requiredMemory);

    /**
     * @brief Gets the ID of the process.
     * @return Process ID.
     */
    int getID() const;

    /**
     * @brief Gets the name of the process.
     * @return Process name.
     */
    std::string getName() const;

    /**
     * @brief Gets the log entries of the process.
     * @return A vector of log strings.
     */
    std::vector<std::string> getLogs() const;

    /**
     * @brief Gets the current line the process is executing.
     * @return Current line number.
     */
    int getCurrentLine() const;

    /**
     * @brief Gets the total number of lines the process will execute.
     * @return Total lines.
     */
    int getTotalLines() const;

    /**
     * @brief Gets the timestamp when the process was created.
     * @return A string containing the formatted timestamp.
     */
    std::string& getTimestamp();

    /**
     * @brief Adds a log entry to the process.
     * @param entry The log entry to add.
     */
    void log(const std::string& entry);
    void safePageFault(int page) const;

    /**
     * @brief Increments the current line number by 1, up to the total number of
     * lines.
     */
    void incrementLine();

    [[nodiscard]] ProcessStatus getStatus() const;
    void setStatus(ProcessStatus newStatus);

    /// @brief Writes the log output to a file in the logs folder.
    ///        Each line includes a timestamp and CPU core ID.
    void writeLogToFile() const;

    void setCurrentCore(int coreId);
    int getCurrentCore() const;
    void setInstructions(const std::vector<std::shared_ptr<Instruction>>& instructions, bool addToMemory = false);
    bool setVariable(const std::string& name, uint16_t value);
    bool getIsFinished() const;
    uint16_t getVariable(const std::string& name);
    uint64_t getWakeupTick() const;
    void setWakeupTick(uint64_t value);
    void setLastInstructionCycle(const uint64_t cycle) {
        lastInstructionCycle = cycle;
    }
    uint64_t getLastInstructionCycle() const {
        return lastInstructionCycle;
    }

    bool declareVariable(const std::string& name, uint16_t value);
    uint64_t getRequiredMemory() const;
    void setBaseAddress(void* ptr);
    void* getBaseAddress() const;
    PageEntry getPageEntry(int pageNumber) const;
    PageData getPageData(int pageNumber) const;

    bool swapPageOut(int pageNumber);
    void swapPageIn(int pageNumber, int frameNumber);
    void shutdown(int invalidAddress);

    void writeToHeap(int address, uint16_t value);
    uint16_t readFromHeap(int address);
    std::uint64_t getMemoryUsage() const;
    void precomputeInstructionPages();
    bool isShutdown() const {
        return didShutdown;
    }
    std::string getShutdownReason() const {
        return shutdownDetails;
    }

private:
    int processID;                  ///< Unique identifier for the process.
    std::string processName;        ///< Name of the process.
    std::vector<std::string> logs;  ///< Log entries generated by the process.
    int currentLine;                ///< Current line number being executed.
    int totalLines;                 ///< Total lines of code the process will execute.
    uint64_t requiredMemory;
    void* baseAddress = nullptr;

    int currentInstructionIndex;  ///< Current instruction being executed
    std::string timestamp;        ///< Timestamp when the process was created.
    std::atomic<ProcessStatus> status;
    std::atomic<int> currentCore;
    uint64_t wakeupTick;
    uint64_t lastInstructionCycle = 0;

    // Upper boundary of each memory segment(text, data, etc.)
    std::unordered_map<MemorySegment, uint16_t> segmentBoundaries;

    std::vector<std::shared_ptr<Instruction>> instructions;
    mutable std::mutex instructionsMutex;

    std::unordered_map<std::string, uint16_t> variableAddresses;
    std::vector<std::string> variableOrder;
    mutable std::mutex variableMutex;

    mutable std::mutex heapMutex;

    static std::pair<int, int> splitAddress(int address);

    std::vector<PageEntry> pageTable;
    mutable std::mutex pageTableMutex;
    std::vector<PageData> precomputedPages;

    bool isValidHeapAddress(int address) const;

    bool didShutdown = false;
    std::string shutdownDetails;

    /**
     * @brief Generates a formatted timestamp for the process creation time.
     * @return A string with the current local date and time.
     */
    static std::string generateTimestamp();
};
