//
// Created by paren on 22/05/2025.
//

#pragma once

#include <atomic>
#include <set>
#include <shared_mutex>
#include <string>
#include <unordered_map>
#include <vector>

#include "Instruction.h"
#include "PrintInstruction.h"

enum ProcessStatus { READY, RUNNING, WAITING, DONE };

struct PageEntry {
    int frameNumber = -1;
    bool isValid;
    bool inBackingStore;
};

/**
 * @class Process
 * @brief Represents a simulated process with logging and line-tracking
 * features.
 */
class Process {
public:
    /**
     * @brief Constructs a Process object.
     * @param id The unique identifier for the process.
     * @param name The name of the process.
     */
    Process(int id, const std::string& name);
    Process(int id, const std::string& name, uint64_t requiredMemory);

    /**
     * @brief Gets the ID of the process.
     * @return Process ID.
     */
    int getID() const;

    /**
     * @brief Gets the name of the process.
     * @return Process name.
     */
    std::string getName() const;

    /**
     * @brief Gets the log entries of the process.
     * @return A vector of log strings.
     */
    std::vector<std::string> getLogs() const;

    /**
     * @brief Gets the current line the process is executing.
     * @return Current line number.
     */
    int getCurrentLine() const;

    /**
     * @brief Gets the total number of lines the process will execute.
     * @return Total lines.
     */
    int getTotalLines() const;

    /**
     * @brief Gets the timestamp when the process was created.
     * @return A string containing the formatted timestamp.
     */
    std::string& getTimestamp();

    /**
     * @brief Adds a log entry to the process.
     * @param entry The log entry to add.
     */
    void log(const std::string& entry);

    /**
     * @brief Increments the current line number by 1, up to the total number of
     * lines.
     */
    void incrementLine();

    [[nodiscard]] ProcessStatus getStatus() const;
    void setStatus(ProcessStatus newStatus);

    /// @brief Writes the log output to a file in the logs folder.
    ///        Each line includes a timestamp and CPU core ID.
    void writeLogToFile() const;

    void setCurrentCore(int coreId);
    int getCurrentCore() const;
    void setInstructions(const std::vector<std::shared_ptr<Instruction>>& instructions);
    bool setVariable(const std::string& name, uint16_t value);
    bool getIsFinished() const;
    uint16_t getVariable(const std::string& name);
    uint64_t getWakeupTick() const;
    void setWakeupTick(const uint64_t value);
    void setLastInstructionCycle(uint64_t cycle) {
        lastInstructionCycle = cycle;
    }
    uint64_t getLastInstructionCycle() const {
        return lastInstructionCycle;
    }

    bool declareVariable(const std::string& name, uint16_t value);
    uint64_t getRequiredMemory() const;
    void setBaseAddress(void* ptr);
    void* getBaseAddress() const;
    PageEntry getPageEntry(int pageNumber) const;

    void swapPageOut(int pageNumber);
    void swapPageIn(int pageNumber, int frameNumber);

    void writeToHeap(int address, uint16_t value);
    uint16_t readFromHeap(int address);

private:
    int processID;                  ///< Unique identifier for the process.
    std::string processName;        ///< Name of the process.
    std::vector<std::string> logs;  ///< Log entries generated by the process.
    int currentLine;                ///< Current line number being executed.
    int totalLines;                 ///< Total lines of code the process will execute.
    uint64_t requiredMemory;
    void* baseAddress = nullptr;

    int currentInstructionIndex;  ///< Current instruction being executed
    std::string timestamp;        ///< Timestamp when the process was created.
    std::atomic<ProcessStatus> status;
    std::atomic<int> currentCore;
    std::vector<std::shared_ptr<Instruction>> instructions;
    std::unordered_map<std::string, uint16_t> variables;
    uint64_t wakeupTick;
    uint64_t lastInstructionCycle = 0;
    std::mutex scopeMutex;
    std::mutex instructionsMutex;

    std::vector<PageEntry> pageTable;
    std::set<int> symbolTablePages;

    std::vector<uint16_t> heapMemory;
    size_t maxHeapMemory;
    int heapStartPage;
    int heapStartOffset;

    bool didShutdown;
    std::string shutdownDetails;

    /**
     * @brief Generates a formatted timestamp for the process creation time.
     * @return A string with the current local date and time.
     */
    std::string generateTimestamp() const;
};
